title: 二叉排序树
author: lichongbing
tags: []
categories:
  - 数据结构
date: 2021-04-25 10:58:00
---
二叉排序树又称二叉查找树或二叉搜索树。
<!--more-->
二叉排序树是一种特殊的二叉树，需要满足以下条件：

（1）如果左子树非空，那么左子树上所有结点的值都小于根结点的值。

 (2）如果右子树非空，那么右子树上所有结点的值都大于根结点的值。

（3）每个结点的左子树和右子树都必须是二叉排序树。

（4）二叉树的所有结点中没有值相等的结点。

1．二叉排序树查找元素

二叉排序树的查找过程如下：

（1）判断根结点的值是否等于查找的值，如果相等，就返回，否则执行（2）。

（2）如果查找的值小于结点的值，就递归查找左子树。

（3）如果查找的值大于结点的值，就递归查找右子树。

（4）二叉排序树中不存在值相等的结点。

在如图2-44所示的二叉排序树查找值为4的元素。

￼![IMG_2864](https://image.lichongbing.com/IMG_2864.JPG)

图2-44　二叉排序树查找元素示意图

二叉排序树的查找过程的时间复杂度是O(log2n)。

2．二叉排序树添加元素

二叉排序树添加元素需要经历查找过程，通过二叉排序树的查找过程找到待添加元素的合适的位置，以保证添加元素后仍满足二叉排序树的要求。

3．二叉排序树删除元素

二叉排序树删除元素分为3种情况，下面分别介绍。

（1）删除的结点是叶子结点

在二叉排序树中删除叶子结点不会破坏二叉排序树的结构，可以直接删除。在图2-44所示的二叉排序树中，需要删除叶子结点1。找到结点1所在的位置，直接删除。删除过程如图2-45所示。

￼![IMG_2866](https://image.lichongbing.com/IMG_2866.JPG)

图2-45　二叉排序树删除叶结点示意图

（2）删除的结点只有左子树或者右子树

在二叉排序树中删除的结点仅有左子树或者右子树，使用左子树或者右子树的根结点替换删除的结点，删除指定的结点。

在图2-44所示的二叉排序树中，删除元素5，需要将结点4移动到结点5的位置，然后删除结点5。删除过程如图2-46所示。

￼![IMG_2867](https://image.lichongbing.com/IMG_2867.JPG)

图2-46　二叉排序树删除仅有一个子结点的结点示意图

（3）删除的结点有左子树和右子树

删除的结点有左子树和右子树，删除该结点后，需要对二叉排序树进行调整。调整的方式有两种，下面分别介绍。

【方案1】从删除的结点的左子树中，找到左子树最右边的结点，即左子树中最大的结点，替换删除的结点；然后进行后续的调整。删除过程如图2-47所示。

![IMG_2868](https://image.lichongbing.com/IMG_2868.JPG)
￼图2-47　二叉排序树删除有左右子结点的结点方案1示意图

方案2】从删除的结点的右子树中，找到右子树最左边的结点，即右子树中最小的结点，替换删除的结点；然后进行后续的调整。删除过程如图2-48所示。

￼![IMG_2869](https://image.lichongbing.com/IMG_2869.JPG)

图2-48　二叉排序树删除有左右子结点的结点方案2示意图

删除二叉排序树的3种情况中，第3种情况可以转化为前两种情况。

当找到删除结点的左子树中的最大结点或者右子树中的最小结点后，对删除的结点进行替换。替换后，替换结点只可能有一棵左子树，或者没有子树，即是叶子结点。

在图2-47中，用于替换的结点5不可能有右子树，如果有，就应该是结点5的右子结点替换结点6。

在图2-48中，用于替换的结点7不可能有左子树，如果有，就应该是结点7的左子结点替换结点6。

4．二叉排序树的实现

二叉排序树的代码实现如下：
```java
**
 * @Author : zhouguanya
 * @Project : java-interview-guide
 * @Date : 2019-04-30 11:04
 * @Version : V1.0
 * @Description : 二叉排序树实现
 */
public class BinarySearchTree {
    private class Node {
        /** 保存结点数据 */
        public int data;
        /** 当前结点的左孩子指针 */
        public Node left;
        /** 当前结点的右孩子指针 */
        public Node right;
        /** 当前结点的父结点 */
        public Node parent;

        /**
         * Node构造器
         *
         * @param value     结点值
         */
        public Node(int value){
            data = value;
            left = null;
            right = null;
            parent = null;
        }
    }
    /** 二叉查找树根结点 */
    private Node root;
    /**
     * 二叉查找树构造器
     */
    public BinarySearchTree(){
        root = null;
    }

    /**
     * 查找指定的元素
     *
     * @param key   待查找的元素
     * @return      返回待查找的元素
     *              如果不存在则返回其父结点
     */
    public Node find(int key) {
        // 从根结点开始遍历
        Node current = root;
        while (current != null) {
            // 如果查找元素小于当前结点的元素
            // 从当前结点的左子树上搜索指定元素
            if (key < current.data) {
                // 当前结点左孩子为空
                if (current.left == null) {
                    return current;
                }
                current = current.left;
                // 如果查找元素大于当前结点的元素
                // 从当前结点的右子树上搜索指定元素
            } else if (key > current.data) {
                // 当前结点右孩子为空
                if (current.right == null) {
                    return current;
                }
                current = current.right;
            } else {
                return current;
            }
        }
        return null;
    }

    /**
     * 添加元素
     *
     * @param value     待插入的元素
     */
    public void put(int value) {
        Node newNode = new Node(value);
        // 如果当前二叉查找树不存在
        if (root == null) {
            root = newNode;
            return;
        }
        Node parent = find(value);
        // 当前值小于父结点值
        if (value < parent.data) {
            parent.left = newNode;
            parent.left.parent = parent;
            return;
        }
        // 当前元素值大于等于父结点的值
        parent.right = newNode;
        parent.right.parent = parent;
    }

    /**
     * 从二叉查找树上删除指定元素
     *
     * 删除元素分为以下情况：
     * 情况1.待删除的结点没有左右子结点，可以直接删除
     * 情况2.待删除的结点存在左子结点或者右子结点，删除后需要对子结点移动
     * 情况3.待删除的结点存在左右2个子结点，可以通过和待删除的结点后继结点交换后转换为情况1或2
     *
     * @param value     待删除元素
     * @return          删除结果
     */
    public boolean remove(int value) {
        Node temp = find(value);
        if (temp.data != value) {
            return false;
        }
        //首先处理第3种情况，删除的结点同时存在左右子树
        if (temp.left != null && temp.right != null) {
            // 待删除结点的后继结点
            Node successor = findSuccessor(temp);
            // 转移待删除结点的后继结点值到当前结点
            temp.data = successor.data;
            // 把待删除的当前结点指向后继结点
            temp = successor;
        }
        //经过上一步处理，下面只有前2种情况，待删除的结点只有1个子结点或者没有结点
        //不管待删除的结点是否有子结点，都获取待删除的结点的子结点
        Node child;
        // 待删除的结点的子结点
        child = temp.left != null ? temp.left : temp.right;
        if (child != null) {
            // 将待删除子结点和待删除结点的父结点关联上
            child.parent = temp.parent;
        }
        // 如果当前待删除的结点没有父结点（后继结点的情况到这儿时一定有父结点）
        // 说明要待删除的就是根结点
        if (temp.parent == null) {
            root = child;
        } else if (temp == temp.parent.left) {
            //当前待删除的结点存在父结点，并且当前待删除的结点是其父结点的一个左结点
            temp.parent.left = child;
        } else if (temp == temp.parent.right) {
            //当前待删除的结点存在父结点，并且当前待删除的结点是其父结点的一个右结点
            temp.parent.right = child;
        }
        return true;
    }

    /**
     * 查询当前结点的后继结点
     * 1.若当前结点没有右孩子，返回当前结点
     * 2.若当前结点有右孩子，返回右子树中最小的大于当前结点的结点
     *
     * @param node  当前结点
     * @return      后继结点
     */
    public Node findSuccessor(Node node) {
        if (node.right == null) {
            return node.parent;
        }
        Node current = node.right;
        Node parent = node.right;
        while (current != null) {
            parent = current;
            current = current.left;
        }
        return parent;
    }

    /**
     * 获取根结点
     *
     * @return  根结点
     */
    public Node getRoot() {
        return root;
    }

    /**
     * 中序遍历
     * 左孩子---->父结点---->右孩子
     *
     * @param node  起始结点
     */
    public void inOrder(Node node) {
        if (node != null) {
            inOrder(node.left);
            System.out.print(node.data + " ");
            inOrder(node.right);
        }
    }

    /**
     * 先序遍历
     * 父结点---->左孩子---->右孩子
     *
     * @param node  起始结点
     */
    public void preOrder(Node node) {
        if (node != null) {
            System.out.print(node.data + " ");
            preOrder(node.left);
            preOrder(node.right);
        }
    }

    /**
     * 后序遍历
     * 左孩子---->右孩子---->父结点
     *
     * @param node  起始结点
     */
    public void postOrder(Node node) {
        if (node != null) {
            postOrder(node.left);
            postOrder(node.right);
            System.out.print(node.data + " ");
        }
    }
}
```

创建二叉排序树的测试类，验证二叉排序树的功能。测试代码如下：
```java

/**
 * @Author : zhouguanya
 * @Project : java-interview-guide
 * @Date : 2019-05-01 14:26
 * @Version : V1.0
 * @Description : 测试二叉排序树
 */
public class BinarySearchTreeDemo {
    public static void main(String[] args) {
        BinarySearchTree binarySearchTree = new BinarySearchTree();
        binarySearchTree.put(6);
        binarySearchTree.put(3);
        binarySearchTree.put(8);
        binarySearchTree.put(10);
        binarySearchTree.put(2);
        binarySearchTree.put(9);
        binarySearchTree.put(5);
        binarySearchTree.put(1);
        binarySearchTree.put(4);
        binarySearchTree.put(7);
        System.out.println("----------二叉排序树中序遍历结果----------");
        binarySearchTree.inOrder(binarySearchTree.getRoot());
        System.out.println();
        System.out.println("----------二叉排序树先序遍历结果----------");
        binarySearchTree.preOrder(binarySearchTree.getRoot());
        System.out.println();
        System.out.println("----------二叉排序树后序遍历结果----------");
        binarySearchTree.postOrder(binarySearchTree.getRoot());
        System.out.println();
        // 删除元素8
        binarySearchTree.remove(8);
        System.out.println("-----二叉排序树删除元素8后中序遍历结果------");
        binarySearchTree.inOrder(binarySearchTree.getRoot());
    }
}
```
执行测试代码，执行结果如下：
```
----------二叉排序树中序遍历结果----------
    1 2 3 4 5 6 7 8 9 10
    ----------二叉排序树先序遍历结果----------
    6 3 2 1 5 4 8 7 10 9
    ----------二叉排序树后序遍历结果----------
    1 2 4 5 3 7 9 10 8 6
    -----二叉排序树删除元素8后中序遍历结果------
    1 2 3 4 5 6 7 9 10
```    